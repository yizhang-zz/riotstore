#ifndef DATA_H
#define DATA_H

/* taken from arithmetic.c from R src */
typedef union
{
   double value;
   unsigned word[2];
} ieee_double;

/* gcc had problems with static const on AIX and Solaris
   Solaris was for gcc 3.1 and 3.2 under -O2 32-bit on 64-bit kernel */
#ifdef _AIX
#define CONST
#elif defined(sparc) && defined (__GNUC__) && __GNUC__ == 3
#define CONST
#else
#define CONST const
#endif

#ifdef WORDS_BIGENDIAN
static CONST int hw = 0;
static CONST int lw = 1;
#else  /* !WORDS_BIGENDIAN */
static CONST int hw = 1;
static CONST int lw = 0;
#endif /* WORDS_BIGENDIAN */

static double R_ValueOfNA()
{
   /* The gcc shipping with RedHat 9 gets this wrong without
    * the volatile declaration. Thanks to Marc Schwartz. */
   volatile ieee_double x;
   x.word[hw] = 0x7ff00000;
   x.word[lw] = 1954;
   return x.value;
};
bool R_IsNA(double x);


#define BLOCK_SIZE 4096
#define NUM_DENSE_ENTRIES ((BLOCK_SIZE - sizeof(BlockHeader))/sizeof(Data))
enum BlockFormat { DENSE, SPARSE };
enum BlockType { LEAF, INTERNAL, ROOT};

typedef uint32_t Key;
typedef double Data;
typedef uint32_t indx_t;

typedef struct 
{
	Key  	key;
	Data 	data;
} Entry;

typedef struct 
{
	Key 	lowerBound;
	Key 	upperBound;
} Range;

typedef struct 
{
	BlockType		type;
	BlockFormat format;
	Range 	range;
	indx_t	nextBlock;
	Data 		defaultValue;
	indx_t nEntries;
	indx_t capacity;
	indx_t parent;
	indx_t pos_in_parent;
	BTree *tree; // only for root block
	indx_t pre; // only for leaves
	indx_t next; // only for leaves
	/* key is 4-byte, so reserve 4 bytes for the prefix; will be enough */
	Key prefix;
	unsigned int compressedKeyLength; /* how many bytes the compressed key takes */
} BlockHeader;

typedef struct 
{
	/* key is 4-byte, so reserve 4 bytes for the prefix; will be enough */
	Key prefix;
	unsigned int compressedKeyLength; /* how many bytes the compressed key takes */
} SparseHeader;


void setRange(Range& range, Key lower, Key upper);
void setBlockHeader(BlockHeader* blockHeader, int type, Range range, indx_t nextBlock, Data def=0, indx_t nEntries=0); 
void setEntry(Entry& entry, Key k, Data d);

#endif
